<html>
  <head>
    <script src="./bpmn-viewer.js"></script>
    <script src="https://aframe.io/releases/0.5.0/aframe.min.js"></script>
    <link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet">
  </head>
  <body>
    <script type="application/javascript">

    const sequenceFlowWidth = 1.2;
    const sequenceFlowHeight = 3.5;
    const taskOutlineWidth = 0.5;
    const gatewayOutlineWidth = 0.5;
    const eventOulineWidth = 0.3;
    const globalScaleFactor = 0.17;
    const layer0 = 0;
    const layer1 = 0.005;
    const layer2 = 0.01;

    function getVectorNormal(vec) {
      const normal = new THREE.Vector2(vec.x, vec.y);

      normal.rotateAround(new THREE.Vector2(0, 0), Math.PI / 2);
      normal.normalize();

      normal.multiplyScalar(sequenceFlowWidth);

      return normal;
    }

    function getAngleBetweenVectors(vec1, vec2) {
      const a = new THREE.Vector2(vec1.x, vec1.y);
      a.normalize();

      const b = new THREE.Vector2(vec2.x, vec2.y);
      b.normalize();
      b.negate();

      const angle = Math.atan2(b.y, b.x) - Math.atan2(a.y, a.x);

      return angle;
    }

    function calculateWaypoints(waypoints) {
      return waypoints.map((waypoint, idx) => {
        const previousWaypoint = waypoints[idx - 1];
        const nextWaypoint = waypoints[idx + 1];

        if(!previousWaypoint) {
          // first waypoint, take the normal
          const movingVector = nextWaypoint.clone().sub(waypoint);
          const normal = getVectorNormal(movingVector);
          const shortNormal = normal.clone().multiplyScalar(.8);
          return [
            waypoint.clone().add(normal),
            waypoint.clone().sub(normal),
            waypoint.clone().add(shortNormal),
            waypoint.clone().sub(shortNormal)
          ];
        } else {
          if(nextWaypoint) {
            // middle point, take the half angle
            const vec1 = waypoint.clone().sub(previousWaypoint);
            const vec2 = nextWaypoint.clone().sub(waypoint);

            const angle = getAngleBetweenVectors(vec1, vec2);
            const halfAngle = angle / 2;

            const normal = vec2.clone().rotateAround(new THREE.Vector2(0, 0), -halfAngle);
            normal.normalize();
            normal.multiplyScalar(sequenceFlowWidth * 1.5);

            const shortNormal = normal.clone().multiplyScalar(.8);

            if(halfAngle < 0) {
              return [
                waypoint.clone().add(normal),
                waypoint.clone().sub(normal),
                waypoint.clone().add(shortNormal),
                waypoint.clone().sub(shortNormal)
              ];
            } else {
              return [
                waypoint.clone().sub(normal),
                waypoint.clone().add(normal),
                waypoint.clone().sub(shortNormal),
                waypoint.clone().add(shortNormal)
              ];
            }
          } else {
            // last waypoint, take the normal
            const movingVector = waypoint.clone().sub(previousWaypoint);
            const normal = getVectorNormal(movingVector);
            const shortNormal = normal.clone().multiplyScalar(.8);

            return [
              waypoint.clone().add(normal),
              waypoint.clone().sub(normal),
              waypoint.clone().add(shortNormal),
              waypoint.clone().sub(shortNormal)
            ];
          }
        }
      });
    }

    AFRAME.registerGeometry('sequenceFlow', {
      schema: {
        points: {
          default: ['0 0', '10 10']
        }
      },

      init: function (data) {
        var geometry = new THREE.Geometry();

        const waypoints = data.points.map(point => {
          return point.split(' ').map(coordinate => parseFloat(coordinate));
        }).map(coordinate => {
          return new THREE.Vector2(coordinate[0], coordinate[1]);
        });

        const mappedWaypoints = calculateWaypoints(waypoints);

        geometry.vertices = [];
        geometry.faces = [];

        mappedWaypoints.forEach((waypoint, idx) => {
          geometry.vertices.push(
            new THREE.Vector3(waypoint[0].y, 0, -waypoint[0].x),
            new THREE.Vector3(waypoint[1].y, 0, -waypoint[1].x),
            new THREE.Vector3(waypoint[0].y, sequenceFlowHeight, -waypoint[0].x),
            new THREE.Vector3(waypoint[1].y, sequenceFlowHeight, -waypoint[1].x),
            new THREE.Vector3(waypoint[2].y, 0, -waypoint[2].x),
            new THREE.Vector3(waypoint[3].y, 0, -waypoint[3].x),
          );

          if(idx > 0) {
            const faceIndexOffset = (idx - 1) * 6;
            geometry.faces.push(new THREE.Face3(4 + faceIndexOffset, 10+ faceIndexOffset, 5 + faceIndexOffset));
            geometry.faces.push(new THREE.Face3(5 + faceIndexOffset, 10+ faceIndexOffset, 11+ faceIndexOffset));
            geometry.faces.push(new THREE.Face3(2 + faceIndexOffset, 3 + faceIndexOffset, 8 + faceIndexOffset));
            geometry.faces.push(new THREE.Face3(3 + faceIndexOffset, 9 + faceIndexOffset, 8 + faceIndexOffset));
            geometry.faces.push(new THREE.Face3(0 + faceIndexOffset, 2 + faceIndexOffset, 6 + faceIndexOffset));
            geometry.faces.push(new THREE.Face3(2 + faceIndexOffset, 8 + faceIndexOffset, 6 + faceIndexOffset));
            geometry.faces.push(new THREE.Face3(1 + faceIndexOffset, 7 + faceIndexOffset, 3 + faceIndexOffset));
            geometry.faces.push(new THREE.Face3(3 + faceIndexOffset, 7 + faceIndexOffset, 9 + faceIndexOffset));
          }
        });

        geometry.computeFaceNormals();
        geometry.computeVertexNormals();
        this.geometry = geometry;
      }
    });


    AFRAME.registerGeometry('sequenceFlowLine', {
      schema: {
        points: {
          default: ['0 0', '10 10']
        }
      },

      init: function (data) {
        var geometry = new THREE.Geometry();

        const waypoints = data.points.map(point => {
          return point.split(' ').map(coordinate => parseFloat(coordinate));
        }).map(coordinate => {
          return new THREE.Vector2(coordinate[0], coordinate[1]);
        });

        const mappedWaypoints = calculateWaypoints(waypoints);

        geometry.vertices = [];
        geometry.faces = [];

        mappedWaypoints.forEach((waypoint, idx) => {
          geometry.vertices.push(
            new THREE.Vector3(waypoint[0].y, 0, -waypoint[0].x),
            new THREE.Vector3(waypoint[1].y, 0, -waypoint[1].x),
            new THREE.Vector3(waypoint[2].y, 0, -waypoint[2].x),
            new THREE.Vector3(waypoint[3].y, 0, -waypoint[3].x),
          );

          if(idx > 0) {
            const faceIndexOffset = (idx - 1) * 4;
            geometry.faces.push(new THREE.Face3(0 + faceIndexOffset, 4 + faceIndexOffset, 2 + faceIndexOffset));
            geometry.faces.push(new THREE.Face3(2 + faceIndexOffset, 4 + faceIndexOffset, 6 + faceIndexOffset));
            geometry.faces.push(new THREE.Face3(3 + faceIndexOffset, 7 + faceIndexOffset, 1 + faceIndexOffset));
            geometry.faces.push(new THREE.Face3(1 + faceIndexOffset, 7 + faceIndexOffset, 5 + faceIndexOffset));
          }
        });

        geometry.computeFaceNormals();
        geometry.computeVertexNormals();
        this.geometry = geometry;
      }
    });


    AFRAME.registerGeometry('task', {
      schema: {
        position: {
          default: '0 0'
        },
        width: {
          default: '10'
        },
        height: {
          default: '10'
        }
      },

      init: function (data) {
        var geometry = new THREE.Geometry();

        const pos = new THREE.Vector2(parseFloat(data.position.split(' ')[0]), parseFloat(data.position.split(' ')[1]));
        const width = parseFloat(data.width);
        const height = parseFloat(data.height);

        geometry.vertices = [
          new THREE.Vector3(pos.y, 0, -pos.x),
          new THREE.Vector3(pos.y + height, 0, -pos.x),
          new THREE.Vector3(pos.y + height, 0, -pos.x - width),
          new THREE.Vector3(pos.y, 0, -pos.x - width)
        ];

        geometry.faces = [
          new THREE.Face3(0, 1, 2),
          new THREE.Face3(2, 3, 0)
        ];

        geometry.computeFaceNormals();
        geometry.computeVertexNormals();
        this.geometry = geometry;
      }
    });

    AFRAME.registerGeometry('gateway', {
      schema: {
        position: {
          default: '0 0'
        }
      },

      init: function (data) {
        var geometry = new THREE.Geometry();

        const pos = new THREE.Vector2(parseFloat(data.position.split(' ')[0]) + gatewayOutlineWidth, parseFloat(data.position.split(' ')[1]) + gatewayOutlineWidth);
        const width = parseFloat(data.width) - 2 * gatewayOutlineWidth;
        const height = parseFloat(data.height) - 2 * gatewayOutlineWidth;

        geometry.vertices = [
          new THREE.Vector3(pos.y, 0, -pos.x - width / 2),
          new THREE.Vector3(pos.y + height / 2, 0, -pos.x),
          new THREE.Vector3(pos.y + height, 0, -pos.x - width / 2),
          new THREE.Vector3(pos.y + height / 2, 0, -pos.x - width)
        ];

        geometry.faces = [
          new THREE.Face3(0, 1, 2),
          new THREE.Face3(2, 3, 0)
        ];

        geometry.computeFaceNormals();
        geometry.computeVertexNormals();
        this.geometry = geometry;
      }
    });

    AFRAME.registerGeometry('gatewayLine', {
      schema: {
        position: {
          default: '0 0'
        }
      },

      init: function (data) {
        var geometry = new THREE.Geometry();

        const pos = new THREE.Vector2(parseFloat(data.position.split(' ')[0]), parseFloat(data.position.split(' ')[1]));

        const width = parseFloat(data.width);
        const height = parseFloat(data.height);

        geometry.vertices = [
          new THREE.Vector3(pos.y, -layer1, -pos.x - width / 2),
          new THREE.Vector3(pos.y + height / 2, -layer1, -pos.x),
          new THREE.Vector3(pos.y + height, -layer1, -pos.x - width / 2),
          new THREE.Vector3(pos.y + height / 2, -layer1, -pos.x - width)
        ];

        geometry.faces = [
          new THREE.Face3(0, 1, 2),
          new THREE.Face3(2, 3, 0)
        ];

        geometry.computeFaceNormals();
        geometry.computeVertexNormals();
        this.geometry = geometry;
      }
    });

    AFRAME.registerGeometry('taskLine', {
      schema: {
        position: {
          default: '0 0'
        },
        width: {
          default: '10'
        },
        height: {
          default: '10'
        }
      },

      init: function (data) {
        var geometry = new THREE.Geometry();

        const pos = new THREE.Vector2(parseFloat(data.position.split(' ')[0]), parseFloat(data.position.split(' ')[1]));
        const width = parseFloat(data.width);
        const height = parseFloat(data.height);

        geometry.vertices = [
            new THREE.Vector3(pos.y + height / 2 - sequenceFlowWidth, layer1, -pos.x),
            new THREE.Vector3(pos.y, layer1, -pos.x),
            new THREE.Vector3(pos.y, layer1, -pos.x - width / 2 + sequenceFlowWidth),
            new THREE.Vector3(pos.y + height / 2 - sequenceFlowWidth - taskOutlineWidth, layer1, -pos.x - taskOutlineWidth),
            new THREE.Vector3(pos.y + taskOutlineWidth, layer1, -pos.x - taskOutlineWidth),
            new THREE.Vector3(pos.y + taskOutlineWidth, layer1, -pos.x - width / 2 + sequenceFlowWidth + taskOutlineWidth),

            new THREE.Vector3(pos.y, layer1, -pos.x - width / 2 - sequenceFlowWidth),
            new THREE.Vector3(pos.y, layer1, -pos.x - width),
            new THREE.Vector3(pos.y + height / 2 - sequenceFlowWidth, layer1, -pos.x - width),
            new THREE.Vector3(pos.y + taskOutlineWidth, layer1, -pos.x - width / 2 - sequenceFlowWidth - taskOutlineWidth),
            new THREE.Vector3(pos.y + taskOutlineWidth, layer1, -pos.x - width + taskOutlineWidth),
            new THREE.Vector3(pos.y + height / 2 - sequenceFlowWidth - taskOutlineWidth, layer1, -pos.x - width + taskOutlineWidth),

            new THREE.Vector3(pos.y + height / 2 + sequenceFlowWidth, layer1, -pos.x),
            new THREE.Vector3(pos.y + height, layer1, -pos.x),
            new THREE.Vector3(pos.y + height, layer1, -pos.x - width / 2 + sequenceFlowWidth),
            new THREE.Vector3(pos.y + height / 2 + sequenceFlowWidth + taskOutlineWidth, layer1, -pos.x - taskOutlineWidth),
            new THREE.Vector3(pos.y + height - taskOutlineWidth, layer1, -pos.x - taskOutlineWidth),
            new THREE.Vector3(pos.y + height - taskOutlineWidth, layer1, -pos.x - width / 2 + sequenceFlowWidth + taskOutlineWidth),

            new THREE.Vector3(pos.y + height, layer1, -pos.x - width / 2 - sequenceFlowWidth),
            new THREE.Vector3(pos.y + height, layer1, -pos.x - width),
            new THREE.Vector3(pos.y + height / 2 + sequenceFlowWidth, layer1, -pos.x - width),
            new THREE.Vector3(pos.y + height - taskOutlineWidth, layer1, -pos.x - width / 2 - sequenceFlowWidth - taskOutlineWidth),
            new THREE.Vector3(pos.y + height - taskOutlineWidth, layer1, -pos.x - width + taskOutlineWidth),
            new THREE.Vector3(pos.y + height / 2 + sequenceFlowWidth + taskOutlineWidth, layer1, -pos.x - width + taskOutlineWidth)
        ];

        geometry.faces = [
          new THREE.Face3(0, 4, 1),
          new THREE.Face3(0, 3, 4),
          new THREE.Face3(1, 4, 2),
          new THREE.Face3(4, 5, 2),

          new THREE.Face3(6,10, 7),
          new THREE.Face3(6, 9, 10),
          new THREE.Face3(7,10, 8),
          new THREE.Face3(10,11, 8),

          new THREE.Face3(12, 13, 16),
          new THREE.Face3(12, 16, 15),
          new THREE.Face3(13, 14, 16),
          new THREE.Face3(16, 14, 17),

          new THREE.Face3(18, 19,22),
          new THREE.Face3(18, 22, 21),
          new THREE.Face3(19, 20,22),
          new THREE.Face3(22, 20,23)


        ];

        // geometry.vertices = [
        //   new THREE.Vector3(pos.y, layer1, -pos.x),
        //   new THREE.Vector3(pos.y + height, layer1, -pos.x),
        //   new THREE.Vector3(pos.y + height, layer1, -pos.x - width),
        //   new THREE.Vector3(pos.y, layer1, -pos.x - width),
        //   new THREE.Vector3(pos.y + taskOutlineWidth, layer1, -pos.x - taskOutlineWidth),
        //   new THREE.Vector3(pos.y + height - taskOutlineWidth, layer1, -pos.x - taskOutlineWidth),
        //   new THREE.Vector3(pos.y + height - taskOutlineWidth, layer1, -pos.x - width + taskOutlineWidth),
        //   new THREE.Vector3(pos.y + taskOutlineWidth, layer1, -pos.x - width + taskOutlineWidth)
        // ];
        //
        // geometry.faces = [
        //   new THREE.Face3(0, 1, 5),
        //   new THREE.Face3(0, 5, 4),
        //   new THREE.Face3(1, 2, 5),
        //   new THREE.Face3(5, 2, 6),
        //   new THREE.Face3(6, 2, 3),
        //   new THREE.Face3(7, 6, 3),
        //   new THREE.Face3(4, 7, 3),
        //   new THREE.Face3(0, 4, 3)
        // ];

        geometry.computeFaceNormals();
        geometry.computeVertexNormals();
        this.geometry = geometry;
      }
    });

    function loadBpmn() {
      const input = document.createElement('input');

      input.setAttribute('type', 'file');
      input.setAttribute('accept', '.bpmn');

      input.addEventListener('change', evt => {
        const file = input.files[0];
        const reader = new FileReader();

        reader.addEventListener('load', e => {
          var BpmnViewer = window.BpmnJS;

          var viewer = new BpmnViewer({ container: document.createElement('div') });

          viewer.importXML(e.target.result, (err, result) => {
            handleModel(viewer);
            document.body.removeChild(splash);
          });
        });

        reader.readAsText(file);
      });

      input.click();

    }

    function handleSequenceFlow(scene, element) {
      /*    <a-entity geometry="primitive: sequenceFlow; points:0 0, 0 5, 0 10, 5 10, 10 10, 10 15;" material="color: #FFFFFF"></a-entity>
            <a-entity geometry="primitive: sequenceFlowLine; points:0 0, 0 5, 0 10, 5 10, 10 10, 10 15;" material="color: #333333"></a-entity>
      */
      const points = element.waypoints.reduce((acc, val) => {
        return acc += (val.x * globalScaleFactor) + ' ' + (val.y * globalScaleFactor) + ', ';
      }, '').slice(0, -2);

      const flow = document.createElement('a-entity');
      flow.setAttribute('geometry', 'primitive: sequenceFlow; points:' + points + ';');
      flow.setAttribute('material', 'color: #FFFFFF; side: double;');

      const line = document.createElement('a-entity');
      line.setAttribute('geometry', 'primitive: sequenceFlowLine; points:' + points + ';');
      line.setAttribute('material', 'color: #333333');

      scene.appendChild(flow);
      scene.appendChild(line);
    }

    function handleEvent(scene, element) {
      /*  <a-entity geometry="primitive: circle; radius: 2;" rotation="-90 0 0" material="color: #FFFFFF" position="5 0 -5"></a-entity>
          <a-entity geometry="primitive: circle; radius: 2.3;" rotation="-90 0 0" material="color: #333333;" position="5 -0.005 -5"></a-entity>
      */

      const posOffset = element.width / 2 * globalScaleFactor;

      const event = document.createElement('a-entity');
      event.setAttribute('geometry', 'primitive: circle; radius:' + (posOffset - eventOulineWidth) + ';');
      event.setAttribute('rotation', '-90 0 0');
      event.setAttribute('position', (element.y * globalScaleFactor + posOffset) + ' 0 ' + -(element.x * globalScaleFactor + posOffset));
      event.setAttribute('material', 'color: #FFFFFF');

      const line = document.createElement('a-entity');
      line.setAttribute('geometry', 'primitive: circle; radius:' + posOffset + ';');
      line.setAttribute('rotation', '-90 0 0');
      line.setAttribute('position', (element.y * globalScaleFactor + posOffset) + ' '+(-layer1)+' ' + -(element.x * globalScaleFactor + posOffset));
      line.setAttribute('material', 'color: #333333');

      scene.appendChild(event);
      scene.appendChild(line);
    }

    function handleGateway(scene, element) {
      /*  <a-entity geometry="primitive: gateway; position: 8 3;" material="color: #FFFFFF;"></a-entity>
          <a-entity geometry="primitive: gatewayLine; position: 8 3;" material="color: #333333"></a-entity>
      */

      const posOffset = element.width / 2 * globalScaleFactor;

      const gateway = document.createElement('a-entity');
      gateway.setAttribute('geometry', 'primitive: gateway; position:' + (element.x * globalScaleFactor) + ' ' + (element.y * globalScaleFactor) + '; width: '+(element.width * globalScaleFactor)+'; height: '+(element.height * globalScaleFactor)+';');
      gateway.setAttribute('material', 'color: #FFFFFF');

      const line = document.createElement('a-entity');
      line.setAttribute('geometry', 'primitive: gatewayLine; position:' + (element.x * globalScaleFactor) + ' ' + (element.y * globalScaleFactor) + '; width: '+(element.width * globalScaleFactor)+'; height: '+(element.height * globalScaleFactor)+';');
      line.setAttribute('material', 'color: #333333');

      scene.appendChild(gateway);
      scene.appendChild(line);
    }

    function handleTask(scene, element) {
      /* <a-entity geometry="primitive: task; position: 10 15; width: 10; height: 10;" material="color: #FFFFFF"></a-entity>
         <a-entity geometry="primitive: taskLine; position: 10 15; width: 10; height: 10;" material="color: #333333"></a-entity>
      */

      const task = document.createElement('a-entity');
      task.setAttribute('geometry', 'primitive: task; position: ' + (element.x * globalScaleFactor) + ' ' + (element.y * globalScaleFactor)+'; width: '+element.width * globalScaleFactor+'; height: '+element.height * globalScaleFactor+';');
      task.setAttribute('material', 'color: #FFFFFF');

      const line = document.createElement('a-entity');
      line.setAttribute('geometry', 'primitive: taskLine; position: ' + (element.x * globalScaleFactor) + ' ' + (element.y * globalScaleFactor)+'; width: '+element.width * globalScaleFactor+'; height: '+element.height * globalScaleFactor+';');
      line.setAttribute('material', 'color: #333333');

      // text label look-controls
      const name = element.businessObject.name;
      const label = document.createElement('a-entity');
      label.setAttribute('rotation', '-90 90 0');
      label.setAttribute('text', 'value: ' + name + '; color: black; width: ' + element.width * globalScaleFactor * 1.7 + ';');
      label.setAttribute('position', (element.y * globalScaleFactor + element.height / 2 * globalScaleFactor) + ' '+(layer1)+' ' + -(element.x * globalScaleFactor + element.width * globalScaleFactor));
      // <a-entity text="value: Hello world; color: black; width: 10;" rotation="-90 0 0"></a-entity>

      // human for usertasks
      if(element.businessObject.$instanceOf('bpmn:UserTask')) {
        //<a-entity obj-model="obj: #human-obj;" scale="0.1 0.1 0.1" rotation="0 90 0"></a-entity>
        const model = document.createElement('a-entity');
        model.setAttribute('obj-model', 'obj: #human-obj;');
        model.setAttribute('scale', '0.2 0.2 0.2');
        model.setAttribute('rotation', '0 90 0');
        model.setAttribute('position', (element.y * globalScaleFactor + element.height / 10 * globalScaleFactor) + ' '+(layer1)+' ' + -(element.x * globalScaleFactor + element.width * globalScaleFactor / 10));

        scene.appendChild(model);
      }

      // computer for serviceTasks
      if(element.businessObject.$instanceOf('bpmn:ServiceTask')) {
        //<a-entity obj-model="obj: #human-obj;" scale="0.1 0.1 0.1" rotation="0 90 0"></a-entity>
        const model = document.createElement('a-entity');
        model.setAttribute('obj-model', 'obj: #computer-obj;');
        model.setAttribute('scale', '0.01 0.01 0.01');
        model.setAttribute('rotation', '0 90 0');
        model.setAttribute('position', (element.y * globalScaleFactor + element.height / 10 * globalScaleFactor) + ' '+(layer1)+' ' + -(element.x * globalScaleFactor + element.width * globalScaleFactor / 10))

        scene.appendChild(model);
      }

      scene.appendChild(task);
      scene.appendChild(line);
      scene.appendChild(label);
    }

    function handleModel(viewer) {
      const scene = document.createElement('a-scene');

      // <a-sky color="#ECECEC"></a-sky>
      const sky = document.createElement('a-sky');
      sky.setAttribute('color', '#ECECEC');
      scene.appendChild(sky);

      /*    <a-assets>
              <a-asset-item id="human-obj" src="/human.obj"></a-asset-item>
            </a-assets>
      */
      const assets = document.createElement('a-assets');

      const humanObj = document.createElement('a-asset-item');
      humanObj.setAttribute('id', 'human-obj');
      humanObj.setAttribute('src', './human.obj');
      assets.appendChild(humanObj);

      const computerObj = document.createElement('a-asset-item');
      computerObj.setAttribute('id', 'computer-obj');
      computerObj.setAttribute('src', './computer.obj');
      assets.appendChild(computerObj);

      scene.appendChild(assets);

      let startPosition;

      const data = [];
      const elementRegistry = viewer.get('elementRegistry');

      elementRegistry.forEach(element => {
        const bo = element.businessObject;
        if(element.type === 'label') {
          return;
        }

        if(bo.$instanceOf('bpmn:SequenceFlow')) {
          handleSequenceFlow(scene, element);
        }

        if(bo.$instanceOf('bpmn:Task')) {
          handleTask(scene, element);
        }

        if(bo.$instanceOf('bpmn:Event')) {
          handleEvent(scene, element);
          if(bo.$instanceOf('bpmn:StartEvent')) {
            startPosition = element;
          }
        }

        if(bo.$instanceOf('bpmn:Gateway')) {
          handleGateway(scene, element);
        }
      });

      // <a-entity camera="userHeight: 1.6" look-controls></a-entity>
      const posOffset = startPosition.width / 2 * globalScaleFactor;
      const camera = document.createElement('a-entity');
      camera.setAttribute('camera', 'userHeight: 1.6');
      camera.setAttribute('look-controls', true);
      camera.setAttribute('wasd-controls', 'acceleration: 250');
      camera.setAttribute('position', (startPosition.y * globalScaleFactor + posOffset) + ' 0 ' + (-startPosition.x * globalScaleFactor - posOffset));
      scene.appendChild(camera);

      document.body.appendChild(scene);
    }

    </script>

    <div style="position:absolute; top: 0; bottom: 0; left: 0; right: 0; background-color: #000000" id="splash">
      <div style="color: #c6caff; text-align: center; font-size: 30em; cursor: pointer;" onClick="loadBpmn()">🦇</div>
      <div style="color: #c6caff; text-align: center; font-size: 8em; font-family: 'Roboto', sans-serif;">BAT</div>
    </div>

    <!-- <a-scene>
      <a-assets>
        <a-asset-item id="human-obj" src="/human.obj"></a-asset-item>
      </a-assets>
      <a-entity geometry="primitive: sequenceFlow; points:0 0, 0 5, 0 10, 5 10, 10 10, 10 15;" material="color: #FFFFFF"></a-entity>
      <a-entity geometry="primitive: sequenceFlowLine; points:0 0, 0 5, 0 10, 5 10, 10 10, 10 15;" material="color: #333333"></a-entity>

      <a-entity geometry="primitive: task; position: 10 15; width: 10; height: 10;" material="color: #FFFFFF"></a-entity>
      <a-entity geometry="primitive: taskLine; position: 10 15; width: 10; height: 10;" material="color: #333333"></a-entity>

      <a-entity geometry="primitive: circle; radius: 2;" rotation="-90 0 0" material="color: #FFFFFF" position="5 0 -5"></a-entity>
      <a-entity geometry="primitive: circle; radius: 2.3;" rotation="-90 0 0" material="color: #333333;" position="5 -0.005 -5"></a-entity>

      <a-entity obj-model="obj: #human-obj;" scale="0.1 0.1 0.1" rotation="0 90 0"></a-entity>

      <a-sky color="#ECECEC"></a-sky>
    </a-scene> -->

  </body>
</html>
