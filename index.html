<html>
  <head>
    <script src="https://aframe.io/releases/0.5.0/aframe.min.js"></script>
  </head>
  <body>
    <script type="application/javascript">

    const sequenceFlowWidth = 1.5;
    const sequenceFlowHeight = 3.5;
    const taskOutlineWidth = 0.5;
    const gatewayOutlineWidth = 0.5;
    const eventRadius = 2;
    const eventOulineWidth = 0.3;

    function getVectorNormal(vec) {
      const normal = new THREE.Vector2(vec.x, vec.y);

      normal.rotateAround(new THREE.Vector2(0, 0), Math.PI / 2);
      normal.normalize();

      normal.multiplyScalar(sequenceFlowWidth);

      return normal;
    }

    function getAngleBetweenVectors(vec1, vec2) {
      const a = new THREE.Vector2(vec1.x, vec1.y);
      a.normalize();

      const b = new THREE.Vector2(vec2.x, vec2.y);
      b.normalize();
      b.negate();

      const angle = Math.atan2(b.y, b.x) - Math.atan2(a.y, a.x);

      return angle;
    }

    function calculateWaypoints(waypoints) {
      return waypoints.map((waypoint, idx) => {
        const previousWaypoint = waypoints[idx - 1];
        const nextWaypoint = waypoints[idx + 1];

        if(!previousWaypoint) {
          // first waypoint, take the normal
          const movingVector = nextWaypoint.clone().sub(waypoint);
          const normal = getVectorNormal(movingVector);
          const shortNormal = normal.clone().multiplyScalar(.8);
          return [
            waypoint.clone().add(normal),
            waypoint.clone().sub(normal),
            waypoint.clone().add(shortNormal),
            waypoint.clone().sub(shortNormal)
          ];
        } else {
          if(nextWaypoint) {
            // middle point, take the half angle
            const vec1 = waypoint.clone().sub(previousWaypoint);
            const vec2 = nextWaypoint.clone().sub(waypoint);

            const angle = getAngleBetweenVectors(vec1, vec2);
            const halfAngle = angle / 2;

            const normal = vec2.clone().rotateAround(new THREE.Vector2(0, 0), -halfAngle);
            normal.normalize();
            normal.multiplyScalar(sequenceFlowWidth);

            const shortNormal = normal.clone().multiplyScalar(.8);

            return [
              waypoint.clone().add(normal),
              waypoint.clone().sub(normal),
              waypoint.clone().add(shortNormal),
              waypoint.clone().sub(shortNormal)
            ];
          } else {
            // last waypoint, take the normal
            const movingVector = waypoint.clone().sub(previousWaypoint);
            const normal = getVectorNormal(movingVector);
            const shortNormal = normal.clone().multiplyScalar(.8);

            return [
              waypoint.clone().add(normal),
              waypoint.clone().sub(normal),
              waypoint.clone().add(shortNormal),
              waypoint.clone().sub(shortNormal)
            ];
          }
        }
      });
    }

    AFRAME.registerGeometry('sequenceFlow', {
      schema: {
        points: {
          default: ['0 0', '10 10']
        }
      },

      init: function (data) {
        var geometry = new THREE.Geometry();

        const waypoints = data.points.map(point => {
          return point.split(' ').map(coordinate => parseInt(coordinate));
        }).map(coordinate => {
          return new THREE.Vector2(coordinate[0], coordinate[1]);
        });

        const mappedWaypoints = calculateWaypoints(waypoints);

        geometry.vertices = [];
        geometry.faces = [];

        mappedWaypoints.forEach((waypoint, idx) => {
          geometry.vertices.push(
            new THREE.Vector3(waypoint[0].y, 0, -waypoint[0].x),
            new THREE.Vector3(waypoint[1].y, 0, -waypoint[1].x),
            new THREE.Vector3(waypoint[0].y, sequenceFlowHeight, -waypoint[0].x),
            new THREE.Vector3(waypoint[1].y, sequenceFlowHeight, -waypoint[1].x),
            new THREE.Vector3(waypoint[2].y, 0, -waypoint[2].x),
            new THREE.Vector3(waypoint[3].y, 0, -waypoint[3].x),
          );

          if(idx > 0) {
            const faceIndexOffset = (idx - 1) * 6;
            geometry.faces.push(new THREE.Face3(4 + faceIndexOffset, 10+ faceIndexOffset, 5 + faceIndexOffset));
            geometry.faces.push(new THREE.Face3(5 + faceIndexOffset, 10+ faceIndexOffset, 11+ faceIndexOffset));
            geometry.faces.push(new THREE.Face3(2 + faceIndexOffset, 3 + faceIndexOffset, 8 + faceIndexOffset));
            geometry.faces.push(new THREE.Face3(3 + faceIndexOffset, 9 + faceIndexOffset, 8 + faceIndexOffset));
            geometry.faces.push(new THREE.Face3(0 + faceIndexOffset, 2 + faceIndexOffset, 6 + faceIndexOffset));
            geometry.faces.push(new THREE.Face3(2 + faceIndexOffset, 8 + faceIndexOffset, 6 + faceIndexOffset));
            geometry.faces.push(new THREE.Face3(1 + faceIndexOffset, 7 + faceIndexOffset, 3 + faceIndexOffset));
            geometry.faces.push(new THREE.Face3(3 + faceIndexOffset, 7 + faceIndexOffset, 9 + faceIndexOffset));
          }
        });

        geometry.computeFaceNormals();
        geometry.computeVertexNormals();
        this.geometry = geometry;
      }
    });


    AFRAME.registerGeometry('sequenceFlowLine', {
      schema: {
        points: {
          default: ['0 0', '10 10']
        }
      },

      init: function (data) {
        var geometry = new THREE.Geometry();

        const waypoints = data.points.map(point => {
          return point.split(' ').map(coordinate => parseInt(coordinate));
        }).map(coordinate => {
          return new THREE.Vector2(coordinate[0], coordinate[1]);
        });

        const mappedWaypoints = calculateWaypoints(waypoints);

        geometry.vertices = [];
        geometry.faces = [];

        mappedWaypoints.forEach((waypoint, idx) => {
          geometry.vertices.push(
            new THREE.Vector3(waypoint[0].y, 0, -waypoint[0].x),
            new THREE.Vector3(waypoint[1].y, 0, -waypoint[1].x),
            new THREE.Vector3(waypoint[2].y, 0, -waypoint[2].x),
            new THREE.Vector3(waypoint[3].y, 0, -waypoint[3].x),
          );

          if(idx > 0) {
            const faceIndexOffset = (idx - 1) * 4;
            geometry.faces.push(new THREE.Face3(0 + faceIndexOffset, 4 + faceIndexOffset, 2 + faceIndexOffset));
            geometry.faces.push(new THREE.Face3(2 + faceIndexOffset, 4 + faceIndexOffset, 6 + faceIndexOffset));
            geometry.faces.push(new THREE.Face3(3 + faceIndexOffset, 7 + faceIndexOffset, 1 + faceIndexOffset));
            geometry.faces.push(new THREE.Face3(1 + faceIndexOffset, 7 + faceIndexOffset, 5 + faceIndexOffset));
          }
        });

        geometry.computeFaceNormals();
        geometry.computeVertexNormals();
        this.geometry = geometry;
      }
    });


    AFRAME.registerGeometry('task', {
      schema: {
        position: {
          default: '0 0'
        },
        width: {
          default: '10'
        },
        height: {
          default: '10'
        }
      },

      init: function (data) {
        var geometry = new THREE.Geometry();

        const pos = new THREE.Vector2(parseInt(data.position.split(' ')[0]) + taskOutlineWidth, parseInt(data.position.split(' ')[1]) + taskOutlineWidth);
        const width = parseInt(data.width) - taskOutlineWidth * 2;
        const height = parseInt(data.height) - taskOutlineWidth * 2;

        geometry.vertices = [
          new THREE.Vector3(pos.y, 0, -pos.x),
          new THREE.Vector3(pos.y + height, 0, -pos.x),
          new THREE.Vector3(pos.y + height, 0, -pos.x - width),
          new THREE.Vector3(pos.y, 0, -pos.x - width)
        ];

        geometry.faces = [
          new THREE.Face3(0, 1, 2),
          new THREE.Face3(2, 3, 0)
        ];

        geometry.computeFaceNormals();
        geometry.computeVertexNormals();
        this.geometry = geometry;
      }
    });

    AFRAME.registerGeometry('gateway', {
      schema: {
        position: {
          default: '0 0'
        }
      },

      init: function (data) {
        var geometry = new THREE.Geometry();

        const pos = new THREE.Vector2(parseInt(data.position.split(' ')[0]) + gatewayOutlineWidth, parseInt(data.position.split(' ')[1]) + gatewayOutlineWidth);
        const width = 6;
        const height = 6;

        geometry.vertices = [
          new THREE.Vector3(pos.y, 0, -pos.x - width / 2),
          new THREE.Vector3(pos.y + height / 2, 0, -pos.x),
          new THREE.Vector3(pos.y + height, 0, -pos.x - width / 2),
          new THREE.Vector3(pos.y + height / 2, 0, -pos.x - width)
        ];

        geometry.faces = [
          new THREE.Face3(0, 1, 2),
          new THREE.Face3(2, 3, 0)
        ];

        geometry.computeFaceNormals();
        geometry.computeVertexNormals();
        this.geometry = geometry;
      }
    });

    AFRAME.registerGeometry('gatewayLine', {
      schema: {
        position: {
          default: '0 0'
        }
      },

      init: function (data) {
        var geometry = new THREE.Geometry();

        const pos = new THREE.Vector2(parseInt(data.position.split(' ')[0]), parseInt(data.position.split(' ')[1]));

        const width = 6 + 2 * gatewayOutlineWidth;
        const height = 6 + 2 * gatewayOutlineWidth;

        geometry.vertices = [
          new THREE.Vector3(pos.y, -0.005, -pos.x - width / 2),
          new THREE.Vector3(pos.y + height / 2, -0.005, -pos.x),
          new THREE.Vector3(pos.y + height, -0.005, -pos.x - width / 2),
          new THREE.Vector3(pos.y + height / 2, -0.005, -pos.x - width)
        ];

        geometry.faces = [
          new THREE.Face3(0, 1, 2),
          new THREE.Face3(2, 3, 0)
        ];

        geometry.computeFaceNormals();
        geometry.computeVertexNormals();
        this.geometry = geometry;
      }
    });

    AFRAME.registerGeometry('taskLine', {
      schema: {
        position: {
          default: '0 0'
        },
        width: {
          default: '10'
        },
        height: {
          default: '10'
        }
      },

      init: function (data) {
        var geometry = new THREE.Geometry();

        const pos = new THREE.Vector2(parseInt(data.position.split(' ')[0]), parseInt(data.position.split(' ')[1]));
        const width = parseInt(data.width);
        const height = parseInt(data.height);

        geometry.vertices = [
          new THREE.Vector3(pos.y, 0, -pos.x),
          new THREE.Vector3(pos.y + height, 0, -pos.x),
          new THREE.Vector3(pos.y + height, 0, -pos.x - width),
          new THREE.Vector3(pos.y, 0, -pos.x - width),
          new THREE.Vector3(pos.y + taskOutlineWidth, 0, -pos.x - taskOutlineWidth),
          new THREE.Vector3(pos.y + height - taskOutlineWidth, 0, -pos.x - taskOutlineWidth),
          new THREE.Vector3(pos.y + height - taskOutlineWidth, 0, -pos.x - width + taskOutlineWidth),
          new THREE.Vector3(pos.y + taskOutlineWidth, 0, -pos.x - width + taskOutlineWidth)
        ];

        geometry.faces = [
          new THREE.Face3(0, 1, 5),
          new THREE.Face3(0, 5, 4),
          new THREE.Face3(1, 2, 5),
          new THREE.Face3(5, 2, 6),
          new THREE.Face3(6, 2, 3),
          new THREE.Face3(7, 6, 3),
          new THREE.Face3(4, 7, 3),
          new THREE.Face3(0, 4, 3)
        ];

        geometry.computeFaceNormals();
        geometry.computeVertexNormals();
        this.geometry = geometry;
      }
    });


    </script>

    <a-scene>
      <a-entity geometry="primitive: sequenceFlow; points:0 0, 0 5, 0 10, 5 10, 10 10, 10 15;" material="color: #FFFFFF"></a-entity>
      <a-entity geometry="primitive: sequenceFlowLine; points:0 0, 0 5, 0 10, 5 10, 10 10, 10 15;" material="color: #333333"></a-entity>

      <a-entity geometry="primitive: task; position: 10 15; width: 10; height: 10;" material="color: #FFFFFF"></a-entity>
      <a-entity geometry="primitive: taskLine; position: 10 15; width: 10; height: 10;" material="color: #333333"></a-entity>

      <a-entity geometry="primitive: circle; radius: 2;" rotation="-90 0 0" material="color: #FFFFFF" position="5 0 -5"></a-entity>
      <a-entity geometry="primitive: circle; radius: 2.3;" rotation="-90 0 0" material="color: #333333;" position="5 -0.005 -5"></a-entity>

      <a-entity geometry="primitive: gateway; position: 8 3;" material="color: #FFFFFF;"></a-entity>
      <a-entity geometry="primitive: gatewayLine; position: 8 3;" material="color: #333333"></a-entity>

      <a-sky color="#ECECEC"></a-sky>
    </a-scene>

  </body>
</html>
