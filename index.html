<html>
  <head>
    <script src="https://aframe.io/releases/0.5.0/aframe.min.js"></script>
  </head>
  <body>
    <script type="application/javascript">

    const sequenceFlowWidth = 1.5;
    const sequenceFlowHeight = 3.5;

    function getVectorNormal(vec) {
      const normal = new THREE.Vector2(vec.x, vec.y);

      normal.rotateAround(new THREE.Vector2(0, 0), Math.PI / 2);
      normal.normalize();

      normal.multiplyScalar(sequenceFlowWidth);

      return normal;
    }

    function getAngleBetweenVectors(vec1, vec2) {
      const a = new THREE.Vector2(vec1.x, vec1.y);
      a.normalize();

      const b = new THREE.Vector2(vec2.x, vec2.y);
      b.normalize();
      b.negate();

      const angle = Math.atan2(b.y, b.x) - Math.atan2(a.y, a.x);

      return angle;
    }

    function calculateWaypoints(waypoints) {
      return waypoints.map((waypoint, idx) => {
        const previousWaypoint = waypoints[idx - 1];
        const nextWaypoint = waypoints[idx + 1];

        if(!previousWaypoint) {
          // first waypoint, take the normal
          const movingVector = nextWaypoint.clone().sub(waypoint);
          const normal = getVectorNormal(movingVector);
          const shortNormal = normal.clone().multiplyScalar(.8);
          return [
            waypoint.clone().add(normal),
            waypoint.clone().sub(normal),
            waypoint.clone().add(shortNormal),
            waypoint.clone().sub(shortNormal)
          ];
        } else {
          if(nextWaypoint) {
            // middle point, take the half angle
            const vec1 = waypoint.clone().sub(previousWaypoint);
            const vec2 = nextWaypoint.clone().sub(waypoint);

            const angle = getAngleBetweenVectors(vec1, vec2);
            const halfAngle = angle / 2;

            const normal = vec2.clone().rotateAround(new THREE.Vector2(0, 0), -halfAngle);
            normal.normalize();
            normal.multiplyScalar(sequenceFlowWidth);

            const shortNormal = normal.clone().multiplyScalar(.8);

            return [
              waypoint.clone().add(normal),
              waypoint.clone().sub(normal),
              waypoint.clone().add(shortNormal),
              waypoint.clone().sub(shortNormal)
            ];
          } else {
            // last waypoint, take the normal
            const movingVector = waypoint.clone().sub(previousWaypoint);
            const normal = getVectorNormal(movingVector);
            const shortNormal = normal.clone().multiplyScalar(.8);

            return [
              waypoint.clone().add(normal),
              waypoint.clone().sub(normal),
              waypoint.clone().add(shortNormal),
              waypoint.clone().sub(shortNormal)
            ];
          }
        }
      });
    }

    AFRAME.registerGeometry('sequenceFlow', {
      schema: {
        points: {
          default: ['0 0', '10 10']
        }
      },

      init: function (data) {
        var geometry = new THREE.Geometry();

        const waypoints = data.points.map(point => {
          return point.split(' ').map(coordinate => parseInt(coordinate));
        }).map(coordinate => {
          return new THREE.Vector2(coordinate[0], coordinate[1]);
        });

        const mappedWaypoints = calculateWaypoints(waypoints);

        geometry.vertices = [];
        geometry.faces = [];

        mappedWaypoints.forEach((waypoint, idx) => {
          geometry.vertices.push(
            new THREE.Vector3(waypoint[0].y, 0, -waypoint[0].x),
            new THREE.Vector3(waypoint[1].y, 0, -waypoint[1].x),
            new THREE.Vector3(waypoint[0].y, sequenceFlowHeight, -waypoint[0].x),
            new THREE.Vector3(waypoint[1].y, sequenceFlowHeight, -waypoint[1].x),
            new THREE.Vector3(waypoint[2].y, 0, -waypoint[2].x),
            new THREE.Vector3(waypoint[3].y, 0, -waypoint[3].x),
          );

          if(idx > 0) {
            const faceIndexOffset = (idx - 1) * 6;
            geometry.faces.push(new THREE.Face3(4 + faceIndexOffset, 10+ faceIndexOffset, 5 + faceIndexOffset));
            geometry.faces.push(new THREE.Face3(5 + faceIndexOffset, 10+ faceIndexOffset, 11+ faceIndexOffset));
            geometry.faces.push(new THREE.Face3(2 + faceIndexOffset, 3 + faceIndexOffset, 8 + faceIndexOffset));
            geometry.faces.push(new THREE.Face3(3 + faceIndexOffset, 9 + faceIndexOffset, 8 + faceIndexOffset));
            geometry.faces.push(new THREE.Face3(0 + faceIndexOffset, 2 + faceIndexOffset, 6 + faceIndexOffset));
            geometry.faces.push(new THREE.Face3(2 + faceIndexOffset, 8 + faceIndexOffset, 6 + faceIndexOffset));
            geometry.faces.push(new THREE.Face3(1 + faceIndexOffset, 7 + faceIndexOffset, 3 + faceIndexOffset));
            geometry.faces.push(new THREE.Face3(3 + faceIndexOffset, 7 + faceIndexOffset, 9 + faceIndexOffset));
          }
        });

        geometry.computeFaceNormals();
        geometry.computeVertexNormals();
        this.geometry = geometry;
      }
    });


    AFRAME.registerGeometry('sequenceFlowLine', {
      schema: {
        points: {
          default: ['0 0', '10 10']
        }
      },

      init: function (data) {
        var geometry = new THREE.Geometry();

        const waypoints = data.points.map(point => {
          return point.split(' ').map(coordinate => parseInt(coordinate));
        }).map(coordinate => {
          return new THREE.Vector2(coordinate[0], coordinate[1]);
        });

        const mappedWaypoints = calculateWaypoints(waypoints);

        geometry.vertices = [];
        geometry.faces = [];

        mappedWaypoints.forEach((waypoint, idx) => {
          geometry.vertices.push(
            new THREE.Vector3(waypoint[0].y, 0, -waypoint[0].x),
            new THREE.Vector3(waypoint[1].y, 0, -waypoint[1].x),
            new THREE.Vector3(waypoint[2].y, 0, -waypoint[2].x),
            new THREE.Vector3(waypoint[3].y, 0, -waypoint[3].x),
          );

          if(idx > 0) {
            const faceIndexOffset = (idx - 1) * 4;
            geometry.faces.push(new THREE.Face3(0 + faceIndexOffset, 4 + faceIndexOffset, 2 + faceIndexOffset));
            geometry.faces.push(new THREE.Face3(2 + faceIndexOffset, 4 + faceIndexOffset, 6 + faceIndexOffset));
            geometry.faces.push(new THREE.Face3(3 + faceIndexOffset, 7 + faceIndexOffset, 1 + faceIndexOffset));
            geometry.faces.push(new THREE.Face3(1 + faceIndexOffset, 7 + faceIndexOffset, 5 + faceIndexOffset));
          }
        });

        geometry.computeFaceNormals();
        geometry.computeVertexNormals();
        this.geometry = geometry;
      }
    });

    </script>

    <a-scene>
      <!-- <a-entity geometry="primitive: hallway; start: 2, 2; end: 0, 6;" material="color: #FFFFFF"></a-entity>
      <a-entity geometry="primitive: hallway; start: 0, 0; end: 8, 3;" material="color: #FFFFFF"></a-entity>
      <a-entity geometry="primitive: hallway; start: 7, 1; end: 16, 9;" material="color: #FFFFFF"></a-entity> -->

      <a-entity geometry="primitive: sequenceFlow; points:0 0, 0 5, 0 10, 5 10, 10 10, 10 15;" material="color: #FFFFFF"></a-entity>
      <a-entity geometry="primitive: sequenceFlowLine; points:0 0, 0 5, 0 10, 5 10, 10 10, 10 15;" material="color: #333333"></a-entity>

      <a-sky color="#ECECEC"></a-sky>
    </a-scene>

  </body>
</html>
