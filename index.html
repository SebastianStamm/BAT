<html>
  <head>
    <script src="./bpmn-viewer.js"></script>
    <script src="https://aframe.io/releases/0.5.0/aframe.min.js"></script>
    <link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet">
  </head>
  <body>
    <script type="application/javascript">

    const sequenceFlowWidth = 1.2;
    const sequenceFlowHeight = 3.5;
    const taskOutlineWidth = 0.5;
    const gatewayOutlineWidth = 0.5;
    const eventOulineWidth = 0.3;
    const globalScaleFactor = 0.12;

    function getVectorNormal(vec) {
      const normal = new THREE.Vector2(vec.x, vec.y);

      normal.rotateAround(new THREE.Vector2(0, 0), Math.PI / 2);
      normal.normalize();

      normal.multiplyScalar(sequenceFlowWidth);

      return normal;
    }

    function getAngleBetweenVectors(vec1, vec2) {
      const a = new THREE.Vector2(vec1.x, vec1.y);
      a.normalize();

      const b = new THREE.Vector2(vec2.x, vec2.y);
      b.normalize();
      b.negate();

      const angle = Math.atan2(b.y, b.x) - Math.atan2(a.y, a.x);

      return angle;
    }

    function calculateWaypoints(waypoints) {
      return waypoints.map((waypoint, idx) => {
        const previousWaypoint = waypoints[idx - 1];
        const nextWaypoint = waypoints[idx + 1];

        if(!previousWaypoint) {
          // first waypoint, take the normal
          const movingVector = nextWaypoint.clone().sub(waypoint);
          const normal = getVectorNormal(movingVector);
          const shortNormal = normal.clone().multiplyScalar(.8);
          return [
            waypoint.clone().add(normal),
            waypoint.clone().sub(normal),
            waypoint.clone().add(shortNormal),
            waypoint.clone().sub(shortNormal)
          ];
        } else {
          if(nextWaypoint) {
            // middle point, take the half angle
            const vec1 = waypoint.clone().sub(previousWaypoint);
            const vec2 = nextWaypoint.clone().sub(waypoint);

            const angle = getAngleBetweenVectors(vec1, vec2);
            const halfAngle = angle / 2;

            const normal = vec2.clone().rotateAround(new THREE.Vector2(0, 0), -halfAngle);
            normal.normalize();
            normal.multiplyScalar(sequenceFlowWidth);

            const shortNormal = normal.clone().multiplyScalar(.8);

            return [
              waypoint.clone().add(normal),
              waypoint.clone().sub(normal),
              waypoint.clone().add(shortNormal),
              waypoint.clone().sub(shortNormal)
            ];
          } else {
            // last waypoint, take the normal
            const movingVector = waypoint.clone().sub(previousWaypoint);
            const normal = getVectorNormal(movingVector);
            const shortNormal = normal.clone().multiplyScalar(.8);

            return [
              waypoint.clone().add(normal),
              waypoint.clone().sub(normal),
              waypoint.clone().add(shortNormal),
              waypoint.clone().sub(shortNormal)
            ];
          }
        }
      });
    }

    AFRAME.registerGeometry('sequenceFlow', {
      schema: {
        points: {
          default: ['0 0', '10 10']
        }
      },

      init: function (data) {
        var geometry = new THREE.Geometry();

        const waypoints = data.points.map(point => {
          return point.split(' ').map(coordinate => parseFloat(coordinate));
        }).map(coordinate => {
          return new THREE.Vector2(coordinate[0], coordinate[1]);
        });

        const mappedWaypoints = calculateWaypoints(waypoints);

        geometry.vertices = [];
        geometry.faces = [];

        mappedWaypoints.forEach((waypoint, idx) => {
          geometry.vertices.push(
            new THREE.Vector3(waypoint[0].y, 0, -waypoint[0].x),
            new THREE.Vector3(waypoint[1].y, 0, -waypoint[1].x),
            new THREE.Vector3(waypoint[0].y, sequenceFlowHeight, -waypoint[0].x),
            new THREE.Vector3(waypoint[1].y, sequenceFlowHeight, -waypoint[1].x),
            new THREE.Vector3(waypoint[2].y, 0, -waypoint[2].x),
            new THREE.Vector3(waypoint[3].y, 0, -waypoint[3].x),
          );

          if(idx > 0) {
            const faceIndexOffset = (idx - 1) * 6;
            geometry.faces.push(new THREE.Face3(4 + faceIndexOffset, 10+ faceIndexOffset, 5 + faceIndexOffset));
            geometry.faces.push(new THREE.Face3(5 + faceIndexOffset, 10+ faceIndexOffset, 11+ faceIndexOffset));
            geometry.faces.push(new THREE.Face3(2 + faceIndexOffset, 3 + faceIndexOffset, 8 + faceIndexOffset));
            geometry.faces.push(new THREE.Face3(3 + faceIndexOffset, 9 + faceIndexOffset, 8 + faceIndexOffset));
            geometry.faces.push(new THREE.Face3(0 + faceIndexOffset, 2 + faceIndexOffset, 6 + faceIndexOffset));
            geometry.faces.push(new THREE.Face3(2 + faceIndexOffset, 8 + faceIndexOffset, 6 + faceIndexOffset));
            geometry.faces.push(new THREE.Face3(1 + faceIndexOffset, 7 + faceIndexOffset, 3 + faceIndexOffset));
            geometry.faces.push(new THREE.Face3(3 + faceIndexOffset, 7 + faceIndexOffset, 9 + faceIndexOffset));
          }
        });

        geometry.computeFaceNormals();
        geometry.computeVertexNormals();
        this.geometry = geometry;
      }
    });


    AFRAME.registerGeometry('sequenceFlowLine', {
      schema: {
        points: {
          default: ['0 0', '10 10']
        }
      },

      init: function (data) {
        var geometry = new THREE.Geometry();

        const waypoints = data.points.map(point => {
          return point.split(' ').map(coordinate => parseFloat(coordinate));
        }).map(coordinate => {
          return new THREE.Vector2(coordinate[0], coordinate[1]);
        });

        const mappedWaypoints = calculateWaypoints(waypoints);

        geometry.vertices = [];
        geometry.faces = [];

        mappedWaypoints.forEach((waypoint, idx) => {
          geometry.vertices.push(
            new THREE.Vector3(waypoint[0].y, 0, -waypoint[0].x),
            new THREE.Vector3(waypoint[1].y, 0, -waypoint[1].x),
            new THREE.Vector3(waypoint[2].y, 0, -waypoint[2].x),
            new THREE.Vector3(waypoint[3].y, 0, -waypoint[3].x),
          );

          if(idx > 0) {
            const faceIndexOffset = (idx - 1) * 4;
            geometry.faces.push(new THREE.Face3(0 + faceIndexOffset, 4 + faceIndexOffset, 2 + faceIndexOffset));
            geometry.faces.push(new THREE.Face3(2 + faceIndexOffset, 4 + faceIndexOffset, 6 + faceIndexOffset));
            geometry.faces.push(new THREE.Face3(3 + faceIndexOffset, 7 + faceIndexOffset, 1 + faceIndexOffset));
            geometry.faces.push(new THREE.Face3(1 + faceIndexOffset, 7 + faceIndexOffset, 5 + faceIndexOffset));
          }
        });

        geometry.computeFaceNormals();
        geometry.computeVertexNormals();
        this.geometry = geometry;
      }
    });


    AFRAME.registerGeometry('task', {
      schema: {
        position: {
          default: '0 0'
        },
        width: {
          default: '10'
        },
        height: {
          default: '10'
        }
      },

      init: function (data) {
        var geometry = new THREE.Geometry();

        const pos = new THREE.Vector2(parseFloat(data.position.split(' ')[0]) + taskOutlineWidth, parseFloat(data.position.split(' ')[1]) + taskOutlineWidth);
        const width = parseFloat(data.width) - taskOutlineWidth * 2;
        const height = parseFloat(data.height) - taskOutlineWidth * 2;

        geometry.vertices = [
          new THREE.Vector3(pos.y, 0, -pos.x),
          new THREE.Vector3(pos.y + height, 0, -pos.x),
          new THREE.Vector3(pos.y + height, 0, -pos.x - width),
          new THREE.Vector3(pos.y, 0, -pos.x - width)
        ];

        geometry.faces = [
          new THREE.Face3(0, 1, 2),
          new THREE.Face3(2, 3, 0)
        ];

        geometry.computeFaceNormals();
        geometry.computeVertexNormals();
        this.geometry = geometry;
      }
    });

    AFRAME.registerGeometry('gateway', {
      schema: {
        position: {
          default: '0 0'
        }
      },

      init: function (data) {
        var geometry = new THREE.Geometry();

        const pos = new THREE.Vector2(parseFloat(data.position.split(' ')[0]) + gatewayOutlineWidth, parseFloat(data.position.split(' ')[1]) + gatewayOutlineWidth);
        const width = 6;
        const height = 6;

        geometry.vertices = [
          new THREE.Vector3(pos.y, 0, -pos.x - width / 2),
          new THREE.Vector3(pos.y + height / 2, 0, -pos.x),
          new THREE.Vector3(pos.y + height, 0, -pos.x - width / 2),
          new THREE.Vector3(pos.y + height / 2, 0, -pos.x - width)
        ];

        geometry.faces = [
          new THREE.Face3(0, 1, 2),
          new THREE.Face3(2, 3, 0)
        ];

        geometry.computeFaceNormals();
        geometry.computeVertexNormals();
        this.geometry = geometry;
      }
    });

    AFRAME.registerGeometry('gatewayLine', {
      schema: {
        position: {
          default: '0 0'
        }
      },

      init: function (data) {
        var geometry = new THREE.Geometry();

        const pos = new THREE.Vector2(parseFloat(data.position.split(' ')[0]), parseFloat(data.position.split(' ')[1]));

        const width = 6 + 2 * gatewayOutlineWidth;
        const height = 6 + 2 * gatewayOutlineWidth;

        geometry.vertices = [
          new THREE.Vector3(pos.y, -0.005, -pos.x - width / 2),
          new THREE.Vector3(pos.y + height / 2, -0.005, -pos.x),
          new THREE.Vector3(pos.y + height, -0.005, -pos.x - width / 2),
          new THREE.Vector3(pos.y + height / 2, -0.005, -pos.x - width)
        ];

        geometry.faces = [
          new THREE.Face3(0, 1, 2),
          new THREE.Face3(2, 3, 0)
        ];

        geometry.computeFaceNormals();
        geometry.computeVertexNormals();
        this.geometry = geometry;
      }
    });

    AFRAME.registerGeometry('taskLine', {
      schema: {
        position: {
          default: '0 0'
        },
        width: {
          default: '10'
        },
        height: {
          default: '10'
        }
      },

      init: function (data) {
        var geometry = new THREE.Geometry();

        const pos = new THREE.Vector2(parseFloat(data.position.split(' ')[0]), parseFloat(data.position.split(' ')[1]));
        const width = parseFloat(data.width);
        const height = parseFloat(data.height);

        geometry.vertices = [
          new THREE.Vector3(pos.y, 0, -pos.x),
          new THREE.Vector3(pos.y + height, 0, -pos.x),
          new THREE.Vector3(pos.y + height, 0, -pos.x - width),
          new THREE.Vector3(pos.y, 0, -pos.x - width),
          new THREE.Vector3(pos.y + taskOutlineWidth, 0, -pos.x - taskOutlineWidth),
          new THREE.Vector3(pos.y + height - taskOutlineWidth, 0, -pos.x - taskOutlineWidth),
          new THREE.Vector3(pos.y + height - taskOutlineWidth, 0, -pos.x - width + taskOutlineWidth),
          new THREE.Vector3(pos.y + taskOutlineWidth, 0, -pos.x - width + taskOutlineWidth)
        ];

        geometry.faces = [
          new THREE.Face3(0, 1, 5),
          new THREE.Face3(0, 5, 4),
          new THREE.Face3(1, 2, 5),
          new THREE.Face3(5, 2, 6),
          new THREE.Face3(6, 2, 3),
          new THREE.Face3(7, 6, 3),
          new THREE.Face3(4, 7, 3),
          new THREE.Face3(0, 4, 3)
        ];

        geometry.computeFaceNormals();
        geometry.computeVertexNormals();
        this.geometry = geometry;
      }
    });

    function loadBpmn() {
      const input = document.createElement('input');

      input.setAttribute('type', 'file');
      input.setAttribute('accept', '.bpmn');

      input.addEventListener('change', evt => {
        const file = input.files[0];
        const reader = new FileReader();

        reader.addEventListener('load', e => {
          console.log('file content', e.target.result);
          var BpmnViewer = window.BpmnJS;

          var viewer = new BpmnViewer({ container: document.createElement('div') });

          viewer.importXML(e.target.result, (err, result) => {
            handleModel(viewer);
            document.body.removeChild(splash);
          });
        });

        reader.readAsText(file);
      });

      input.click();

    }

    function handleSequenceFlow(scene, element) {
      /*    <a-entity geometry="primitive: sequenceFlow; points:0 0, 0 5, 0 10, 5 10, 10 10, 10 15;" material="color: #FFFFFF"></a-entity>
            <a-entity geometry="primitive: sequenceFlowLine; points:0 0, 0 5, 0 10, 5 10, 10 10, 10 15;" material="color: #333333"></a-entity>
      */
      const points = element.waypoints.reduce((acc, val) => {
        return acc += (val.x * globalScaleFactor) + ' ' + (val.y * globalScaleFactor) + ', ';
      }, '').slice(0, -2);

      console.log('points', points);

      const flow = document.createElement('a-entity');
      flow.setAttribute('geometry', 'primitive: sequenceFlow; points:' + points + ';');
      flow.setAttribute('material', 'color: #FFFFFF');

      const line = document.createElement('a-entity');
      line.setAttribute('geometry', 'primitive: sequenceFlowLine; points:' + points + ';');
      line.setAttribute('material', 'color: #333333');

      scene.appendChild(flow);
      scene.appendChild(line);
    }

    function handleEvent(scene, element) {
      /*  <a-entity geometry="primitive: circle; radius: 2;" rotation="-90 0 0" material="color: #FFFFFF" position="5 0 -5"></a-entity>
          <a-entity geometry="primitive: circle; radius: 2.3;" rotation="-90 0 0" material="color: #333333;" position="5 -0.005 -5"></a-entity>
      */

      console.log('got event', element);
      const posOffset = element.width / 2 * globalScaleFactor;

      const event = document.createElement('a-entity');
      event.setAttribute('geometry', 'primitive: circle; radius:' + (posOffset - eventOulineWidth) + ';');
      event.setAttribute('rotation', '-90 0 0');
      event.setAttribute('position', (element.y * globalScaleFactor + posOffset) + ' 0 ' + -(element.x * globalScaleFactor + posOffset));
      event.setAttribute('material', 'color: #FFFFFF');

      const line = document.createElement('a-entity');
      line.setAttribute('geometry', 'primitive: circle; radius:' + posOffset + ';');
      line.setAttribute('rotation', '-90 0 0');
      line.setAttribute('position', (element.y * globalScaleFactor + posOffset) + ' -0.005 ' + -(element.x * globalScaleFactor + posOffset));
      line.setAttribute('material', 'color: #333333');

      scene.appendChild(event);
      scene.appendChild(line);
    }

    function handleTask(scene, element) {
      /* <a-entity geometry="primitive: task; position: 10 15; width: 10; height: 10;" material="color: #FFFFFF"></a-entity>
         <a-entity geometry="primitive: taskLine; position: 10 15; width: 10; height: 10;" material="color: #333333"></a-entity>
      */
      const task = document.createElement('a-entity');
      task.setAttribute('geometry', 'primitive: task; position: ' + (element.x * globalScaleFactor) + ' ' + (element.y * globalScaleFactor)+'; width: '+element.width * globalScaleFactor+'; height: '+element.height * globalScaleFactor+';');
      task.setAttribute('material', 'color: #FFFFFF');

      const line = document.createElement('a-entity');
      line.setAttribute('geometry', 'primitive: taskLine; position: ' + (element.x * globalScaleFactor) + ' ' + (element.y * globalScaleFactor)+'; width: '+element.width * globalScaleFactor+'; height: '+element.height * globalScaleFactor+';');
      line.setAttribute('material', 'color: #333333');

      scene.appendChild(task);
      scene.appendChild(line);
    }

    function handleModel(viewer) {
      const scene = document.createElement('a-scene');

      // <a-sky color="#ECECEC"></a-sky>
      const sky = document.createElement('a-sky');
      sky.setAttribute('color', '#ECECEC');

      scene.appendChild(sky);

      window.viewer = viewer;

      const data = [];
      const elementRegistry = viewer.get('elementRegistry');

      elementRegistry.forEach(element => {
        console.log('element', element);
        const bo = element.businessObject;
        if(element.type === 'label') {
          return;
        }

        if(bo.$instanceOf('bpmn:SequenceFlow')) {
          handleSequenceFlow(scene, element);
        }

        if(bo.$instanceOf('bpmn:Task')) {
          handleTask(scene, element);
        }

        if(bo.$instanceOf('bpmn:Event')) {
          handleEvent(scene, element);
        }
      });

      document.body.appendChild(scene);
    }

    </script>

    <div style="position:absolute; top: 0; bottom: 0; left: 0; right: 0; background-color: #000000" id="splash">
      <div style="color: white; text-align: center; font-size: 30em; cursor: pointer;" onClick="loadBpmn()">🦇</div>
      <div style="color: white; text-align: center; font-size: 8em; font-family: 'Roboto', sans-serif;">BAT</div>
    </div>

    <!-- <a-scene>
      <a-entity geometry="primitive: sequenceFlow; points:0 0, 0 5, 0 10, 5 10, 10 10, 10 15;" material="color: #FFFFFF"></a-entity>
      <a-entity geometry="primitive: sequenceFlowLine; points:0 0, 0 5, 0 10, 5 10, 10 10, 10 15;" material="color: #333333"></a-entity>

      <a-entity geometry="primitive: task; position: 10 15; width: 10; height: 10;" material="color: #FFFFFF"></a-entity>
      <a-entity geometry="primitive: taskLine; position: 10 15; width: 10; height: 10;" material="color: #333333"></a-entity>

      <a-entity geometry="primitive: circle; radius: 2;" rotation="-90 0 0" material="color: #FFFFFF" position="5 0 -5"></a-entity>
      <a-entity geometry="primitive: circle; radius: 2.3;" rotation="-90 0 0" material="color: #333333;" position="5 -0.005 -5"></a-entity>

      <a-entity geometry="primitive: gateway; position: 8 3;" material="color: #FFFFFF;"></a-entity>
      <a-entity geometry="primitive: gatewayLine; position: 8 3;" material="color: #333333"></a-entity>

      <a-sky color="#ECECEC"></a-sky>
    </a-scene> -->

  </body>
</html>
