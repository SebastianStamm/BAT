<html>
  <head>
    <script src="./bpmn-viewer.js"></script>
    <script src="https://aframe.io/releases/0.5.0/aframe.min.js"></script>
    <link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet">
  </head>
  <body>
    <script type="application/javascript">

    const bpmnXml = `<?xml version="1.0" encoding="UTF-8"?>
    <bpmn:definitions xmlns:bpmn="http://www.omg.org/spec/BPMN/20100524/MODEL" xmlns:bpmndi="http://www.omg.org/spec/BPMN/20100524/DI" xmlns:dc="http://www.omg.org/spec/DD/20100524/DC" xmlns:di="http://www.omg.org/spec/DD/20100524/DI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" id="Definitions_1" targetNamespace="http://bpmn.io/schema/bpmn">
      <bpmn:process id="Process_1" isExecutable="false">
        <bpmn:startEvent id="StartEvent_1">
          <bpmn:outgoing>SequenceFlow_0x23rei</bpmn:outgoing>
        </bpmn:startEvent>
        <bpmn:sequenceFlow id="SequenceFlow_0x23rei" sourceRef="StartEvent_1" targetRef="Task_0uu2aok" />
        <bpmn:userTask id="Task_0uu2aok" name="foobar">
          <bpmn:incoming>SequenceFlow_0x23rei</bpmn:incoming>
          <bpmn:outgoing>SequenceFlow_01dx52h</bpmn:outgoing>
        </bpmn:userTask>
        <bpmn:endEvent id="EndEvent_1thnu37">
          <bpmn:incoming>SequenceFlow_0559nkc</bpmn:incoming>
        </bpmn:endEvent>
        <bpmn:sequenceFlow id="SequenceFlow_01dx52h" sourceRef="Task_0uu2aok" targetRef="ExclusiveGateway_1n8lkxs" />
        <bpmn:exclusiveGateway id="ExclusiveGateway_1n8lkxs">
          <bpmn:incoming>SequenceFlow_01dx52h</bpmn:incoming>
          <bpmn:outgoing>SequenceFlow_0559nkc</bpmn:outgoing>
          <bpmn:outgoing>SequenceFlow_0w8bh64</bpmn:outgoing>
        </bpmn:exclusiveGateway>
        <bpmn:sequenceFlow id="SequenceFlow_0559nkc" sourceRef="ExclusiveGateway_1n8lkxs" targetRef="EndEvent_1thnu37" />
        <bpmn:endEvent id="EndEvent_03ieesg">
          <bpmn:incoming>SequenceFlow_0m2yiuk</bpmn:incoming>
        </bpmn:endEvent>
        <bpmn:sequenceFlow id="SequenceFlow_0w8bh64" sourceRef="ExclusiveGateway_1n8lkxs" targetRef="Task_1fb2om7" />
        <bpmn:sequenceFlow id="SequenceFlow_0m2yiuk" sourceRef="Task_1fb2om7" targetRef="EndEvent_03ieesg" />
        <bpmn:serviceTask id="Task_1fb2om7" name="this is a service task">
          <bpmn:incoming>SequenceFlow_0w8bh64</bpmn:incoming>
          <bpmn:outgoing>SequenceFlow_0m2yiuk</bpmn:outgoing>
        </bpmn:serviceTask>
      </bpmn:process>
      <bpmndi:BPMNDiagram id="BPMNDiagram_1">
        <bpmndi:BPMNPlane id="BPMNPlane_1" bpmnElement="Process_1">
          <bpmndi:BPMNShape id="_BPMNShape_StartEvent_2" bpmnElement="StartEvent_1">
            <dc:Bounds x="184" y="147" width="36" height="36" />
            <bpmndi:BPMNLabel>
              <dc:Bounds x="157" y="183" width="90" height="20" />
            </bpmndi:BPMNLabel>
          </bpmndi:BPMNShape>
          <bpmndi:BPMNEdge id="SequenceFlow_0x23rei_di" bpmnElement="SequenceFlow_0x23rei">
            <di:waypoint xsi:type="dc:Point" x="220" y="165" />
            <di:waypoint xsi:type="dc:Point" x="319" y="165" />
            <bpmndi:BPMNLabel>
              <dc:Bounds x="269.5" y="144" width="0" height="12" />
            </bpmndi:BPMNLabel>
          </bpmndi:BPMNEdge>
          <bpmndi:BPMNShape id="UserTask_0cisdy6_di" bpmnElement="Task_0uu2aok">
            <dc:Bounds x="319" y="125" width="100" height="80" />
          </bpmndi:BPMNShape>
          <bpmndi:BPMNShape id="EndEvent_1thnu37_di" bpmnElement="EndEvent_1thnu37">
            <dc:Bounds x="688" y="147" width="36" height="36" />
            <bpmndi:BPMNLabel>
              <dc:Bounds x="661" y="187" width="90" height="12" />
            </bpmndi:BPMNLabel>
          </bpmndi:BPMNShape>
          <bpmndi:BPMNEdge id="SequenceFlow_01dx52h_di" bpmnElement="SequenceFlow_01dx52h">
            <di:waypoint xsi:type="dc:Point" x="419" y="165" />
            <di:waypoint xsi:type="dc:Point" x="517" y="165" />
            <bpmndi:BPMNLabel>
              <dc:Bounds x="423" y="144" width="90" height="12" />
            </bpmndi:BPMNLabel>
          </bpmndi:BPMNEdge>
          <bpmndi:BPMNShape id="ExclusiveGateway_1n8lkxs_di" bpmnElement="ExclusiveGateway_1n8lkxs" isMarkerVisible="true">
            <dc:Bounds x="517" y="140" width="50" height="50" />
            <bpmndi:BPMNLabel>
              <dc:Bounds x="542" y="194" width="0" height="12" />
            </bpmndi:BPMNLabel>
          </bpmndi:BPMNShape>
          <bpmndi:BPMNEdge id="SequenceFlow_0559nkc_di" bpmnElement="SequenceFlow_0559nkc">
            <di:waypoint xsi:type="dc:Point" x="567" y="165" />
            <di:waypoint xsi:type="dc:Point" x="688" y="165" />
            <bpmndi:BPMNLabel>
              <dc:Bounds x="627.5" y="144" width="0" height="12" />
            </bpmndi:BPMNLabel>
          </bpmndi:BPMNEdge>
          <bpmndi:BPMNShape id="EndEvent_03ieesg_di" bpmnElement="EndEvent_03ieesg">
            <dc:Bounds x="688" y="344" width="36" height="36" />
            <bpmndi:BPMNLabel>
              <dc:Bounds x="706" y="384" width="0" height="12" />
            </bpmndi:BPMNLabel>
          </bpmndi:BPMNShape>
          <bpmndi:BPMNEdge id="SequenceFlow_0w8bh64_di" bpmnElement="SequenceFlow_0w8bh64">
            <di:waypoint xsi:type="dc:Point" x="542" y="190" />
            <di:waypoint xsi:type="dc:Point" x="542" y="322" />
            <bpmndi:BPMNLabel>
              <dc:Bounds x="557" y="250" width="0" height="12" />
            </bpmndi:BPMNLabel>
          </bpmndi:BPMNEdge>
          <bpmndi:BPMNEdge id="SequenceFlow_0m2yiuk_di" bpmnElement="SequenceFlow_0m2yiuk">
            <di:waypoint xsi:type="dc:Point" x="592" y="362" />
            <di:waypoint xsi:type="dc:Point" x="688" y="362" />
            <bpmndi:BPMNLabel>
              <dc:Bounds x="640" y="341" width="0" height="12" />
            </bpmndi:BPMNLabel>
          </bpmndi:BPMNEdge>
          <bpmndi:BPMNShape id="ServiceTask_0pxu4as_di" bpmnElement="Task_1fb2om7">
            <dc:Bounds x="492" y="322" width="100" height="80" />
          </bpmndi:BPMNShape>
        </bpmndi:BPMNPlane>
      </bpmndi:BPMNDiagram>
    </bpmn:definitions>
`;

    const sequenceFlowWidth = 1.2;
    const sequenceFlowHeight = 3.5;
    const taskOutlineWidth = 0.5;
    const gatewayOutlineWidth = 0.5;
    const eventOulineWidth = 0.3;
    const globalScaleFactor = 0.17;

    function getVectorNormal(vec) {
      const normal = new THREE.Vector2(vec.x, vec.y);

      normal.rotateAround(new THREE.Vector2(0, 0), Math.PI / 2);
      normal.normalize();

      normal.multiplyScalar(sequenceFlowWidth);

      return normal;
    }

    function getAngleBetweenVectors(vec1, vec2) {
      const a = new THREE.Vector2(vec1.x, vec1.y);
      a.normalize();

      const b = new THREE.Vector2(vec2.x, vec2.y);
      b.normalize();
      b.negate();

      const angle = Math.atan2(b.y, b.x) - Math.atan2(a.y, a.x);

      return angle;
    }

    function calculateWaypoints(waypoints) {
      return waypoints.map((waypoint, idx) => {
        const previousWaypoint = waypoints[idx - 1];
        const nextWaypoint = waypoints[idx + 1];

        if(!previousWaypoint) {
          // first waypoint, take the normal
          const movingVector = nextWaypoint.clone().sub(waypoint);
          const normal = getVectorNormal(movingVector);
          const shortNormal = normal.clone().multiplyScalar(.8);
          return [
            waypoint.clone().add(normal),
            waypoint.clone().sub(normal),
            waypoint.clone().add(shortNormal),
            waypoint.clone().sub(shortNormal)
          ];
        } else {
          if(nextWaypoint) {
            // middle point, take the half angle
            const vec1 = waypoint.clone().sub(previousWaypoint);
            const vec2 = nextWaypoint.clone().sub(waypoint);

            const angle = getAngleBetweenVectors(vec1, vec2);
            const halfAngle = angle / 2;

            const normal = vec2.clone().rotateAround(new THREE.Vector2(0, 0), -halfAngle);
            normal.normalize();
            normal.multiplyScalar(sequenceFlowWidth);

            const shortNormal = normal.clone().multiplyScalar(.8);

            return [
              waypoint.clone().add(normal),
              waypoint.clone().sub(normal),
              waypoint.clone().add(shortNormal),
              waypoint.clone().sub(shortNormal)
            ];
          } else {
            // last waypoint, take the normal
            const movingVector = waypoint.clone().sub(previousWaypoint);
            const normal = getVectorNormal(movingVector);
            const shortNormal = normal.clone().multiplyScalar(.8);

            return [
              waypoint.clone().add(normal),
              waypoint.clone().sub(normal),
              waypoint.clone().add(shortNormal),
              waypoint.clone().sub(shortNormal)
            ];
          }
        }
      });
    }

    AFRAME.registerGeometry('sequenceFlow', {
      schema: {
        points: {
          default: ['0 0', '10 10']
        }
      },

      init: function (data) {
        var geometry = new THREE.Geometry();

        const waypoints = data.points.map(point => {
          return point.split(' ').map(coordinate => parseFloat(coordinate));
        }).map(coordinate => {
          return new THREE.Vector2(coordinate[0], coordinate[1]);
        });

        const mappedWaypoints = calculateWaypoints(waypoints);

        geometry.vertices = [];
        geometry.faces = [];

        mappedWaypoints.forEach((waypoint, idx) => {
          geometry.vertices.push(
            new THREE.Vector3(waypoint[0].y, 0, -waypoint[0].x),
            new THREE.Vector3(waypoint[1].y, 0, -waypoint[1].x),
            new THREE.Vector3(waypoint[0].y, sequenceFlowHeight, -waypoint[0].x),
            new THREE.Vector3(waypoint[1].y, sequenceFlowHeight, -waypoint[1].x),
            new THREE.Vector3(waypoint[2].y, 0, -waypoint[2].x),
            new THREE.Vector3(waypoint[3].y, 0, -waypoint[3].x),
          );

          if(idx > 0) {
            const faceIndexOffset = (idx - 1) * 6;
            geometry.faces.push(new THREE.Face3(4 + faceIndexOffset, 10+ faceIndexOffset, 5 + faceIndexOffset));
            geometry.faces.push(new THREE.Face3(5 + faceIndexOffset, 10+ faceIndexOffset, 11+ faceIndexOffset));
            geometry.faces.push(new THREE.Face3(2 + faceIndexOffset, 3 + faceIndexOffset, 8 + faceIndexOffset));
            geometry.faces.push(new THREE.Face3(3 + faceIndexOffset, 9 + faceIndexOffset, 8 + faceIndexOffset));
            geometry.faces.push(new THREE.Face3(0 + faceIndexOffset, 2 + faceIndexOffset, 6 + faceIndexOffset));
            geometry.faces.push(new THREE.Face3(2 + faceIndexOffset, 8 + faceIndexOffset, 6 + faceIndexOffset));
            geometry.faces.push(new THREE.Face3(1 + faceIndexOffset, 7 + faceIndexOffset, 3 + faceIndexOffset));
            geometry.faces.push(new THREE.Face3(3 + faceIndexOffset, 7 + faceIndexOffset, 9 + faceIndexOffset));
          }
        });

        geometry.computeFaceNormals();
        geometry.computeVertexNormals();
        this.geometry = geometry;
      }
    });


    AFRAME.registerGeometry('sequenceFlowLine', {
      schema: {
        points: {
          default: ['0 0', '10 10']
        }
      },

      init: function (data) {
        var geometry = new THREE.Geometry();

        const waypoints = data.points.map(point => {
          return point.split(' ').map(coordinate => parseFloat(coordinate));
        }).map(coordinate => {
          return new THREE.Vector2(coordinate[0], coordinate[1]);
        });

        const mappedWaypoints = calculateWaypoints(waypoints);

        geometry.vertices = [];
        geometry.faces = [];

        mappedWaypoints.forEach((waypoint, idx) => {
          geometry.vertices.push(
            new THREE.Vector3(waypoint[0].y, 0, -waypoint[0].x),
            new THREE.Vector3(waypoint[1].y, 0, -waypoint[1].x),
            new THREE.Vector3(waypoint[2].y, 0, -waypoint[2].x),
            new THREE.Vector3(waypoint[3].y, 0, -waypoint[3].x),
          );

          if(idx > 0) {
            const faceIndexOffset = (idx - 1) * 4;
            geometry.faces.push(new THREE.Face3(0 + faceIndexOffset, 4 + faceIndexOffset, 2 + faceIndexOffset));
            geometry.faces.push(new THREE.Face3(2 + faceIndexOffset, 4 + faceIndexOffset, 6 + faceIndexOffset));
            geometry.faces.push(new THREE.Face3(3 + faceIndexOffset, 7 + faceIndexOffset, 1 + faceIndexOffset));
            geometry.faces.push(new THREE.Face3(1 + faceIndexOffset, 7 + faceIndexOffset, 5 + faceIndexOffset));
          }
        });

        geometry.computeFaceNormals();
        geometry.computeVertexNormals();
        this.geometry = geometry;
      }
    });


    AFRAME.registerGeometry('task', {
      schema: {
        position: {
          default: '0 0'
        },
        width: {
          default: '10'
        },
        height: {
          default: '10'
        }
      },

      init: function (data) {
        var geometry = new THREE.Geometry();

        const pos = new THREE.Vector2(parseFloat(data.position.split(' ')[0]) + taskOutlineWidth, parseFloat(data.position.split(' ')[1]) + taskOutlineWidth);
        const width = parseFloat(data.width) - taskOutlineWidth * 2;
        const height = parseFloat(data.height) - taskOutlineWidth * 2;

        geometry.vertices = [
          new THREE.Vector3(pos.y, 0, -pos.x),
          new THREE.Vector3(pos.y + height, 0, -pos.x),
          new THREE.Vector3(pos.y + height, 0, -pos.x - width),
          new THREE.Vector3(pos.y, 0, -pos.x - width)
        ];

        geometry.faces = [
          new THREE.Face3(0, 1, 2),
          new THREE.Face3(2, 3, 0)
        ];

        geometry.computeFaceNormals();
        geometry.computeVertexNormals();
        this.geometry = geometry;
      }
    });

    AFRAME.registerGeometry('gateway', {
      schema: {
        position: {
          default: '0 0'
        }
      },

      init: function (data) {
        var geometry = new THREE.Geometry();

        const pos = new THREE.Vector2(parseFloat(data.position.split(' ')[0]) + gatewayOutlineWidth, parseFloat(data.position.split(' ')[1]) + gatewayOutlineWidth);
        const width = parseFloat(data.width) - 2 * gatewayOutlineWidth;
        const height = parseFloat(data.height) - 2 * gatewayOutlineWidth;

        geometry.vertices = [
          new THREE.Vector3(pos.y, 0, -pos.x - width / 2),
          new THREE.Vector3(pos.y + height / 2, 0, -pos.x),
          new THREE.Vector3(pos.y + height, 0, -pos.x - width / 2),
          new THREE.Vector3(pos.y + height / 2, 0, -pos.x - width)
        ];

        geometry.faces = [
          new THREE.Face3(0, 1, 2),
          new THREE.Face3(2, 3, 0)
        ];

        geometry.computeFaceNormals();
        geometry.computeVertexNormals();
        this.geometry = geometry;
      }
    });

    AFRAME.registerGeometry('gatewayLine', {
      schema: {
        position: {
          default: '0 0'
        }
      },

      init: function (data) {
        var geometry = new THREE.Geometry();

        const pos = new THREE.Vector2(parseFloat(data.position.split(' ')[0]), parseFloat(data.position.split(' ')[1]));

        const width = parseFloat(data.width);
        const height = parseFloat(data.height);

        geometry.vertices = [
          new THREE.Vector3(pos.y, -0.005, -pos.x - width / 2),
          new THREE.Vector3(pos.y + height / 2, -0.005, -pos.x),
          new THREE.Vector3(pos.y + height, -0.005, -pos.x - width / 2),
          new THREE.Vector3(pos.y + height / 2, -0.005, -pos.x - width)
        ];

        geometry.faces = [
          new THREE.Face3(0, 1, 2),
          new THREE.Face3(2, 3, 0)
        ];

        geometry.computeFaceNormals();
        geometry.computeVertexNormals();
        this.geometry = geometry;
      }
    });

    AFRAME.registerGeometry('taskLine', {
      schema: {
        position: {
          default: '0 0'
        },
        width: {
          default: '10'
        },
        height: {
          default: '10'
        }
      },

      init: function (data) {
        var geometry = new THREE.Geometry();

        const pos = new THREE.Vector2(parseFloat(data.position.split(' ')[0]), parseFloat(data.position.split(' ')[1]));
        const width = parseFloat(data.width);
        const height = parseFloat(data.height);

        geometry.vertices = [
          new THREE.Vector3(pos.y, 0, -pos.x),
          new THREE.Vector3(pos.y + height, 0, -pos.x),
          new THREE.Vector3(pos.y + height, 0, -pos.x - width),
          new THREE.Vector3(pos.y, 0, -pos.x - width),
          new THREE.Vector3(pos.y + taskOutlineWidth, 0, -pos.x - taskOutlineWidth),
          new THREE.Vector3(pos.y + height - taskOutlineWidth, 0, -pos.x - taskOutlineWidth),
          new THREE.Vector3(pos.y + height - taskOutlineWidth, 0, -pos.x - width + taskOutlineWidth),
          new THREE.Vector3(pos.y + taskOutlineWidth, 0, -pos.x - width + taskOutlineWidth)
        ];

        geometry.faces = [
          new THREE.Face3(0, 1, 5),
          new THREE.Face3(0, 5, 4),
          new THREE.Face3(1, 2, 5),
          new THREE.Face3(5, 2, 6),
          new THREE.Face3(6, 2, 3),
          new THREE.Face3(7, 6, 3),
          new THREE.Face3(4, 7, 3),
          new THREE.Face3(0, 4, 3)
        ];

        geometry.computeFaceNormals();
        geometry.computeVertexNormals();
        this.geometry = geometry;
      }
    });

    function loadBpmn() {
      const input = document.createElement('input');

      input.setAttribute('type', 'file');
      input.setAttribute('accept', '.bpmn');

      input.addEventListener('change', evt => {
        const file = input.files[0];
        const reader = new FileReader();

        reader.addEventListener('load', e => {
          console.log('file content', e.target.result);
          var BpmnViewer = window.BpmnJS;

          var viewer = new BpmnViewer({ container: document.createElement('div') });

          viewer.importXML(e.target.result, (err, result) => {
            handleModel(viewer);
            document.body.removeChild(splash);
          });
        });

        reader.readAsText(file);
      });

      input.click();

    }

    function handleSequenceFlow(scene, element) {
      /*    <a-entity geometry="primitive: sequenceFlow; points:0 0, 0 5, 0 10, 5 10, 10 10, 10 15;" material="color: #FFFFFF"></a-entity>
            <a-entity geometry="primitive: sequenceFlowLine; points:0 0, 0 5, 0 10, 5 10, 10 10, 10 15;" material="color: #333333"></a-entity>
      */
      const points = element.waypoints.reduce((acc, val) => {
        return acc += (val.x * globalScaleFactor) + ' ' + (val.y * globalScaleFactor) + ', ';
      }, '').slice(0, -2);

      console.log('points', points);

      const flow = document.createElement('a-entity');
      flow.setAttribute('geometry', 'primitive: sequenceFlow; points:' + points + ';');
      flow.setAttribute('material', 'color: #FFFFFF; side: double;');

      const line = document.createElement('a-entity');
      line.setAttribute('geometry', 'primitive: sequenceFlowLine; points:' + points + ';');
      line.setAttribute('material', 'color: #333333');

      scene.appendChild(flow);
      scene.appendChild(line);
    }

    function handleEvent(scene, element) {
      /*  <a-entity geometry="primitive: circle; radius: 2;" rotation="-90 0 0" material="color: #FFFFFF" position="5 0 -5"></a-entity>
          <a-entity geometry="primitive: circle; radius: 2.3;" rotation="-90 0 0" material="color: #333333;" position="5 -0.005 -5"></a-entity>
      */

      console.log('got event', element);
      const posOffset = element.width / 2 * globalScaleFactor;

      const event = document.createElement('a-entity');
      event.setAttribute('geometry', 'primitive: circle; radius:' + (posOffset - eventOulineWidth) + ';');
      event.setAttribute('rotation', '-90 0 0');
      event.setAttribute('position', (element.y * globalScaleFactor + posOffset) + ' 0 ' + -(element.x * globalScaleFactor + posOffset));
      event.setAttribute('material', 'color: #FFFFFF');

      const line = document.createElement('a-entity');
      line.setAttribute('geometry', 'primitive: circle; radius:' + posOffset + ';');
      line.setAttribute('rotation', '-90 0 0');
      line.setAttribute('position', (element.y * globalScaleFactor + posOffset) + ' -0.005 ' + -(element.x * globalScaleFactor + posOffset));
      line.setAttribute('material', 'color: #333333');

      scene.appendChild(event);
      scene.appendChild(line);
    }

    function handleGateway(scene, element) {
      /*  <a-entity geometry="primitive: gateway; position: 8 3;" material="color: #FFFFFF;"></a-entity>
          <a-entity geometry="primitive: gatewayLine; position: 8 3;" material="color: #333333"></a-entity>
      */

      console.log('got gateway', element);
      const posOffset = element.width / 2 * globalScaleFactor;

      const gateway = document.createElement('a-entity');
      gateway.setAttribute('geometry', 'primitive: gateway; position:' + (element.x * globalScaleFactor) + ' ' + (element.y * globalScaleFactor) + '; width: '+(element.width * globalScaleFactor)+'; height: '+(element.height * globalScaleFactor)+';');
      gateway.setAttribute('material', 'color: #FFFFFF');

      const line = document.createElement('a-entity');
      line.setAttribute('geometry', 'primitive: gatewayLine; position:' + (element.x * globalScaleFactor) + ' ' + (element.y * globalScaleFactor) + '; width: '+(element.width * globalScaleFactor)+'; height: '+(element.height * globalScaleFactor)+';');
      line.setAttribute('material', 'color: #333333');

      scene.appendChild(gateway);
      scene.appendChild(line);
    }

    function handleTask(scene, element) {
      /* <a-entity geometry="primitive: task; position: 10 15; width: 10; height: 10;" material="color: #FFFFFF"></a-entity>
         <a-entity geometry="primitive: taskLine; position: 10 15; width: 10; height: 10;" material="color: #333333"></a-entity>
      */
      console.log('handling task', element);

      const task = document.createElement('a-entity');
      task.setAttribute('geometry', 'primitive: task; position: ' + (element.x * globalScaleFactor) + ' ' + (element.y * globalScaleFactor)+'; width: '+element.width * globalScaleFactor+'; height: '+element.height * globalScaleFactor+';');
      task.setAttribute('material', 'color: #FFFFFF');

      const line = document.createElement('a-entity');
      line.setAttribute('geometry', 'primitive: taskLine; position: ' + (element.x * globalScaleFactor) + ' ' + (element.y * globalScaleFactor)+'; width: '+element.width * globalScaleFactor+'; height: '+element.height * globalScaleFactor+';');
      line.setAttribute('material', 'color: #333333');

      // text label look-controls
      const name = element.businessObject.name;
      const label = document.createElement('a-entity');
      label.setAttribute('rotation', '-90 90 0');
      label.setAttribute('text', 'value: ' + name + '; color: black; width: ' + element.width * globalScaleFactor * 1.7 + ';');
      label.setAttribute('position', (element.y * globalScaleFactor + element.height / 2 * globalScaleFactor) + ' 0.005 ' + -(element.x * globalScaleFactor + element.width * globalScaleFactor));
      // <a-entity text="value: Hello world; color: black; width: 10;" rotation="-90 0 0"></a-entity>

      // human for usertasks
      if(element.businessObject.$instanceOf('bpmn:UserTask')) {
        //<a-entity obj-model="obj: #human-obj;" scale="0.1 0.1 0.1" rotation="0 90 0"></a-entity>
        const model = document.createElement('a-entity');
        model.setAttribute('obj-model', 'obj: #human-obj;');
        model.setAttribute('scale', '0.2 0.2 0.2');
        model.setAttribute('rotation', '0 90 0');
        model.setAttribute('position', (element.y * globalScaleFactor + element.height / 10 * globalScaleFactor) + ' 0.005 ' + -(element.x * globalScaleFactor + element.width * globalScaleFactor / 10))

        scene.appendChild(model);
      }

      // computer for serviceTasks
      if(element.businessObject.$instanceOf('bpmn:ServiceTask')) {
        //<a-entity obj-model="obj: #human-obj;" scale="0.1 0.1 0.1" rotation="0 90 0"></a-entity>
        const model = document.createElement('a-entity');
        model.setAttribute('obj-model', 'obj: #computer-obj;');
        model.setAttribute('scale', '0.01 0.01 0.01');
        model.setAttribute('rotation', '0 90 0');
        model.setAttribute('position', (element.y * globalScaleFactor + element.height / 10 * globalScaleFactor) + ' 0.005 ' + -(element.x * globalScaleFactor + element.width * globalScaleFactor / 10))

        scene.appendChild(model);
      }

      scene.appendChild(task);
      scene.appendChild(line);
      scene.appendChild(label);
    }

    function handleModel(viewer) {
      const scene = document.createElement('a-scene');

      // <a-sky color="#ECECEC"></a-sky>
      const sky = document.createElement('a-sky');
      sky.setAttribute('color', '#ECECEC');
      scene.appendChild(sky);

      /*    <a-assets>
              <a-asset-item id="human-obj" src="/human.obj"></a-asset-item>
            </a-assets>
      */
      const assets = document.createElement('a-assets');

      const humanObj = document.createElement('a-asset-item');
      humanObj.setAttribute('id', 'human-obj');
      humanObj.setAttribute('src', '/human.obj');
      assets.appendChild(humanObj);

      const computerObj = document.createElement('a-asset-item');
      computerObj.setAttribute('id', 'computer-obj');
      computerObj.setAttribute('src', '/computer.obj');
      assets.appendChild(computerObj);

      scene.appendChild(assets);

      let startPosition;

      const data = [];
      const elementRegistry = viewer.get('elementRegistry');

      elementRegistry.forEach(element => {
        const bo = element.businessObject;
        if(element.type === 'label') {
          return;
        }

        if(bo.$instanceOf('bpmn:SequenceFlow')) {
          handleSequenceFlow(scene, element);
        }

        if(bo.$instanceOf('bpmn:Task')) {
          handleTask(scene, element);
        }

        if(bo.$instanceOf('bpmn:Event')) {
          handleEvent(scene, element);
          if(bo.$instanceOf('bpmn:StartEvent')) {
            startPosition = element;
          }
        }

        if(bo.$instanceOf('bpmn:Gateway')) {
          handleGateway(scene, element);
        }
      });

      // <a-entity camera="userHeight: 1.6" look-controls></a-entity>
      const posOffset = startPosition.width / 2 * globalScaleFactor;
      const camera = document.createElement('a-entity');
      camera.setAttribute('camera', 'userHeight: 1.6');
      camera.setAttribute('look-controls', true);
      camera.setAttribute('wasd-controls', 'acceleration: 250');
      camera.setAttribute('position', (startPosition.y * globalScaleFactor + posOffset) + ' 0 ' + (-startPosition.x * globalScaleFactor - posOffset));
      scene.appendChild(camera);

      document.body.appendChild(scene);
    }

    window.setTimeout(() => {
      var BpmnViewer = window.BpmnJS;

      var viewer = new BpmnViewer({ container: document.createElement('div') });

      viewer.importXML(bpmnXml, (err, result) => {
        handleModel(viewer);
        document.body.removeChild(splash);
      });
    }, 500);

    </script>

    <div style="position:absolute; top: 0; bottom: 0; left: 0; right: 0; background-color: #000000" id="splash">
      <div style="color: white; text-align: center; font-size: 30em; cursor: pointer;" onClick="loadBpmn()">🦇</div>
      <div style="color: white; text-align: center; font-size: 8em; font-family: 'Roboto', sans-serif;">BAT</div>
    </div>

    <!-- <a-scene>
      <a-assets>
        <a-asset-item id="human-obj" src="/human.obj"></a-asset-item>
      </a-assets>
      <a-entity geometry="primitive: sequenceFlow; points:0 0, 0 5, 0 10, 5 10, 10 10, 10 15;" material="color: #FFFFFF"></a-entity>
      <a-entity geometry="primitive: sequenceFlowLine; points:0 0, 0 5, 0 10, 5 10, 10 10, 10 15;" material="color: #333333"></a-entity>

      <a-entity geometry="primitive: task; position: 10 15; width: 10; height: 10;" material="color: #FFFFFF"></a-entity>
      <a-entity geometry="primitive: taskLine; position: 10 15; width: 10; height: 10;" material="color: #333333"></a-entity>

      <a-entity geometry="primitive: circle; radius: 2;" rotation="-90 0 0" material="color: #FFFFFF" position="5 0 -5"></a-entity>
      <a-entity geometry="primitive: circle; radius: 2.3;" rotation="-90 0 0" material="color: #333333;" position="5 -0.005 -5"></a-entity>

      <a-entity obj-model="obj: #human-obj;" scale="0.1 0.1 0.1" rotation="0 90 0"></a-entity>

      <a-sky color="#ECECEC"></a-sky>
    </a-scene> -->

  </body>
</html>
